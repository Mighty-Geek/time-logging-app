import * as React from 'react';
import Sequencer from './sequencer';
import { WithSequencerProps, SequencerState, InjectedAPI, InjectedProps } from './types';
declare const withSequencer: (options?: WithSequencerProps | undefined) => <BaseProps extends InjectedProps>(Component: React.ComponentType<BaseProps>) => {
    new (props: Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "sequencer">> & WithSequencerProps): {
        sequencer: Sequencer;
        componentWillReceiveProps(nextProps: Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "sequencer">> & WithSequencerProps): void;
        getApi(): InjectedAPI;
        handleChange: (sequencerState: SequencerState) => void;
        render(): JSX.Element;
        context: any;
        setState<K extends "sequencer">(state: InjectedProps | ((prevState: Readonly<InjectedProps>, props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "sequencer">> & WithSequencerProps>) => InjectedProps | Pick<InjectedProps, K> | null) | Pick<InjectedProps, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callBack?: (() => void) | undefined): void;
        readonly props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "sequencer">> & WithSequencerProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<InjectedProps>;
        refs: {
            [key: string]: React.ReactInstance;
        };
    };
    defaultProps: WithSequencerProps;
    contextType?: React.Context<any> | undefined;
};
export default withSequencer;
